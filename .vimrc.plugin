"              o8o                                       
"              `"'                                       
" oooo    ooo oooo  ooo. .oo.  .oo.   oooo d8b  .ooooo.  
"  `88.  .8'  `888  `888P"Y88bP"Y88b  `888""8P d88' `"Y8 
"   `88..8'    888   888   888   888   888     888       
"    `888'     888   888   888   888   888     888   .o8 
"     `8'     o888o o888o o888o o888o d888b    `Y8bod8P' 
"                                                        
"                                                        
"                                                        
"            oooo                          o8o              
"            `888                          `"'              
" oo.ooooo.   888  oooo  oooo   .oooooooo oooo  ooo. .oo.   
"  888' `88b  888  `888  `888  888' `88b  `888  `888P"Y88b  
"  888   888  888   888   888  888   888   888   888   888  
"  888   888  888   888   888  `88bod8P'   888   888   888  
"  888bod8P' o888o  `V88V"V8P' `8oooooo.  o888o o888o o888o 
"  888                         d"     YD                    
" o888o                        "Y88888P'                    
"                                                           

"
" Buftabs:
"
function! g:Date()
	return strftime("%Y/%m/%d %H:%M")
endfunction

set statusline=%{buftabs}%=%m\ %y%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}\ %4l/%4L,%3c\ %3p%%\ (%{g:Date()})

let w:buftabs_enabled         = 0
let g:buftabs_only_basename   = 1
let g:buftabs_in_statusline   = 1
let g:buftabs_marker_start    = "["
let g:buftabs_marker_end      = "]"
let g:buftabs_separator       = "#"
let g:buftabs_marker_modified = "+"
let g:buftabs_active_highlight_group = "Visual"
let w:original_statusline = matchstr(&statusline, "%=.*")

if &diff
	finish
endif

function! Buftabs_enable()
	let w:buftabs_enabled = 1
endfunction

let s:Pecho=''
function! s:Pecho(msg)
	if &ut!=1|let s:hold_ut=&ut|let &ut=1|en
	let s:Pecho=a:msg
	aug Pecho
		au CursorHold * if s:Pecho!=''|echo s:Pecho
					\|let s:Pecho=''|let &ut=s:hold_ut|en
				\|aug Pecho|exe 'au!'|aug END|aug! Pecho
	aug END
endf

function! Buftabs_show(deleted_buf)
	let l:i = 1
	let s:list = ''
	let l:start = 0
	let l:end = 0
	if ! exists("w:from") 
		let w:from = 0
	endif

	if ! exists("w:buftabs_enabled")
endfunction

"	nnoremap <silent><Space>j :Unite file_mru -direction=botright -toggle<CR>
"	nnoremap <silent><Space>k :YRShow<CR>
"	nnoremap <silent><Space>o :Unite outline -direction=botright -toggle<CR>
"	
"	" openbrowser-open
"	nmap gW <Plug>(openbrowser-open)
"	vmap <Leader>s <Plug>(openbrowser-smart-search)
"	nmap <Leader>w <Plug>(openbrowser-open)
"	
"	" Splash-vim
"	if !has('gui_running')
"		let g:loaded_splash = 0 "(on=1 / off=0)
"	endif
"	
"	" MRU
"	let MRU_Use_Alt_useopen = 1 "Open MRU by line number
"	let MRU_Window_Height   = 20
"	let MRU_Max_Entries     = 100
"	let MRU_Use_CursorLine  = 1
"	
"	" Neocomplcache
"	highlight Pmenu      ctermbg=lightcyan ctermfg=black
"	highlight PmenuSel   ctermbg=blue      ctermfg=black
"	highlight PmenuSbari ctermbg=darkgray
"	highlight PmenuThumb ctermbg=lightgray
"	set completeopt=menuone                             "Setting about complement window
"	let g:neocomplcache_enable_at_startup = 1           "Enable to startup NeoComplCache
"	let g:neocomplcache_enable_smart_case = 1           "Ignore capital and small
"	let g:neocomplcache_enable_underbar_completion = 1  "Enable to complement include underbar
"	let g:neocomplcache_max_list = 20                   "The number of displayed candidates at pop-up menu
"	let g:neocomplcache_min_syntax_length = 3           "The smallest strings when cashing syntax
"	"Determine candidates selected now
"	inoremap <expr><C-y> neocomplcache#close_popup()
"	" Cancel complement that was carried out last time
"	inoremap <expr><C-g> neocomplcache#undo_completion()
"	" Complement common parts among complement candidates
"	inoremap <expr><C-l> neocomplcache#complete_common_string()
"	" Cancel candidates selected now and close pop-up
"	inoremap <expr><C-e> neocomplcache#cancel_popup()
"	" Enable to move by cursor key during insert mode (5 lines)
"	let g:neocomplcache_enable_insert_char_pre = 1
"	if !exists('g:neocomplcache_keyword_patterns')
"	        let g:neocomplcache_keyword_patterns = {}
"	endif
"	let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"	
"	" display on commandline intead of statusline
"	nmap n <Plug>(anzu-n-with-echo)
"	nmap N <Plug>(anzu-N-with-echo)
"	nmap * <Plug>(anzu-star-with-echo)
"	nmap # <Plug>(anzu-sharp-with-echo)
"	
"	" Unite
"	let g:unite_winwidth                   = 40
"	let g:unite_source_file_mru_limit      = 300
"	let g:unite_enable_start_insert        = 0 " off is zero
"	let g:unite_enable_split_vertically    = 0
"	let g:unite_source_history_yank_enable = 1 " enable history/yank
"	let g:unite_source_file_mru_filename_format  = ''
"	let g:unite_kind_jump_list_after_jump_scroll = 0
"	call unite#custom_default_action('directory' , 'tabvimfiler')
"	call unite#custom_default_action("directory_mru", "vimfiler")
"	
"	" Keyborad Mappings On Unite
"	autocmd FileType unite call s:unite_my_settings()
"	function! s:unite_my_settings() "{{
"		" Exit unite by ESC
"		nmap <buffer> <ESC> <Plug>(unite_exit)
"		" By inputting jj to be able to normal mode when insert mode
"		imap <buffer> jj <Plug>(unite_insert_leave)
"		" ctrl+w ;; delete words and backslash
"		imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
"		nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
"		inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
"		nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
"		inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
"	endfunction "}}
"	
"	" Filter of file_mru(unite.vim)
"	call unite#custom_filters('file_mru',
"				\ ['matcher_file_name', 'sorter_default', 'converter_file_directory'])
"	
"	let g:splash#path = expand('$HOME/tux.txt')
